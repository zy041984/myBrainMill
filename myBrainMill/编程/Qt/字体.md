# QFont
应用程序用来指定字体属性的类，字体最重要的属性是family，其余属性是尺寸，磅数(应该是粗体细体)，词间距，字间距，stretch(宽度缩放)
# QFontInfo
实际渲染时使用的字体的属性信息
它与QFont类的属性区别，
QFont类的属性指的是应用程序需求的属性，例如指定使用25Pt的字体，但是实际渲染时可能在操作系统中找不到该字体，只好使用24Pt的字体，QFontInfo返回的就是24Pt，即实际渲染使用的属性
## PixelSize
设定字体大小为像素大小，与设备无关。
## PointSize
设定字体大小的另一种方式，由于精度原因实际渲染效果可能无法达到设定值
## Weight
类似于操作系统或css中指定的字号，从enum QFont::Weight中获取数值，大概数值从0到87，字体从thin到bold。
## fixedPitch
等宽字体
# QFontMetrics
用于计算字符和字符串的size。注意区分打印机字体和适用于屏幕的字体
![字符尺寸图](./QFontMetrics2.png)
baseline就是基线
Ascent就是基线到字符最高处距离
descent就是基线到字符最低处距离
leading应该是上一行的最低到下一行的最高距离，能否理解为行距
lineHeight就是字符高度加行距
使用QPainter绘制文本，drawText的时候，文字坐标系原点是Origin，也就是基线上的点，而不是文本左上角
width就是字符串文本的总宽度
如果设定了自动换行，在知道宽度的基础上，boundingRect可以计算出字符串文本的总高度
所以在一个矩形中绘制自动换行的文本，可以先设定宽度，再boundingRect来计算文本的高度，从而绘制外包围矩形
```
QFont f;
f.setPixelSize(30);
f.setStretch(QFont::UltraExpanded);
QFontMetrics FontMetric1 = QFontMetrics(f);
qDebug()<<FontMetric1.boundingRect("hello wolrd");
```
写了个简单界面测试控件大小随字体大小改变，
跨显示器实现字体物理高度不变。

测试发现setPixelSize确实可以跨显示器字体物理高度不变，输入参数是根据显示器DPI计算物理高度多少mm的字体需要多少个像素，但是DPI一定要用实际物理尺寸计算出来的。
Qt查询出来的DPI有两种，物理DPI大概计算的，逻辑DPI可能是把物理DPI取了整
查询出来的DPI显示器与实际情况差别不大，但是电视与实际情况差了3倍。有可能是显卡设置中为电视设置了缩放，待测试。
但是电视分辨率太大了，显示器上看着正好的字体电视上看有点小，所以实际使用的时候暂用查询出来的逻辑DPI吧。
测试发现页面布局确实可以根据字体来重新计算控件宽度和高度了，并且ScrollArea可以保证页面不合适的时候出现水平和垂直滚动条
测试发现win+shift+方向触发了move事件

控件根据文字改变尺寸，翻译过来的文字也可以
```
QCoreApplication::setAttribute(Qt::AA_DisableHighDpiScaling);//必须在创建QGuiApplication前就设置这个属性
```
没有详细测试这句话，想来因为setPixelSize输入参数是根据显示器DPI计算物理高度多少mm的字体需要多少个像素，所以不管是否设置这句话，都要保证系统缩放DPI或改分辨率或切换屏幕时获得正确的物理DPI
```
foreach(QLabel* sb, findChildren<QLabel*>())
{
QFontMetrics fm(sb->font());
QRect textRect = fm.boundingRect(sb->text());
sb->setMinimumSize(textRect.width(), textRect.height());
sb->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::MinimumExpanding);
}
```
设置了控件的最小尺寸，让layout根据sizePolicy自动计算控件尺寸

# 源代码
qtbase\src\gui\kernel\qhighdpiscaling.cpp里面讲了坐标系，scaleFactor等等
qtbase\src\plugins\platforms\windows\qwindowsscreen.cpp里面有使用系统SDK获得显示器属性
qtbase\src\plugins\platforms\windows\qwindowsscreen.cpp里面QWindowsScreen::pixelDensity表现了根据系统实时DPI估算比例的不准确过程
# 5.12.12进一步详细测试
20250829用Qt5.12.12详细测试了QFontSize的实例程序
## 调试Qt源代码
- Qt内部获得系统分辨率，DPI，物理尺寸，使用了GetDeviceCaps，GetMonitorInfo
- 修改windows系统缩放的时候，可以获得实时的DPI，即缩放从100%到150%，操作系统给出的DPI从96变化到144
- EnableHighDpiScaling的时候，根据`实时DPI/96`，计算的值再四舍五入得到一个比例(很有可能就是devicePixelRatio)，根据这个比例重新计算QScreen的geometry，逻辑DPI和物理DPI，所以结果不准确。
- DisableHighDpiScaling的时候，根据windows系统的文本缩放实时获得DPI(准确值，以96DPI为基准)。QScreen的geometry，物理DPI与未缩放的时候相同，只有逻辑DPI实时更新了
实测程序
支持以上结论
## 关于字体
在word中用小一号写的字，小一号相当于24磅，一磅等于1/72英寸，即小一号相当于逻辑上的1/3英寸
再根据实时DPI就可以计算出小一号字体的实际像素=`1/3英寸*96DPI=32像素`。从实际像素与物理DPI就可以计算出物理尺寸。
- 如果只修改桌面分辨率，实时DPI就是操作系统给出的分辨率还是96没变，小一号字体的像素数没变。但是桌面一个像素表示的实际尺寸(物理DPI)变了，所以实际物理尺寸变了
- 如果修改系统缩放，桌面分辨率不变，系统会给出一个新的缩放的DPI，小一号字体的像素数变了，桌面一个像素表示的实际尺寸(物理DPI)没变，所以实际物理尺寸变了
## 解决文字显示不全的方案
使用DisableHighDpiScaling，文字固定为小四号，磅数12，像素是16
- 监测windows系统的缩放，可能要从windows获得，根据实时DPI计算缩放比例，把小四字体的像素相应缩放，再输入给QFont::setPixelSize，再重新计算QFontMetrics::boundingRect用来设置控件的最小尺寸
- moveEvent或resizeEvent发现改了显示器之后，虽然dpi可能变了，但是字体像素不变。只需重新计算各控件的QFontMetrics::boundingRect用来设置控件的最小尺寸
- 所有界面做成scollArea，gridLayout布局，各控件设置MinExpand
- 主界面响应move resize，发送重新计算尺寸消息给各控件
- 主界面监视系统缩放，发送字体更新像素消息给各控件
图片怎么处理，暂时没想好