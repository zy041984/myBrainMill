[RPOJ_箜_Kong的博客-CSDN博客](https://blog.csdn.net/liminlu0314/category_9182214.html)

https://www.bilibili.com/video/BV1XE411o7kE/

# 第一讲 编译
vpb是生成高效动态调度地形的OSG扩展，可以把高程和纹理生成一个地形

49分钟左右讲了vpb的一个程序osgdem的功能
用mspaint画了一张黑白图，保存为tiff格式，然后就可以用osgdem转换为高程地形，黑白即代表不同高度。可以把这个tiff文件转换为ive文件，然后用osgviewer显示，这张tiff图片还可以作为贴图

# 第二讲 基于MFC的程序框架
用基于MFC的单文档窗口做了程序框架
自定义的view类要响应几种消息，CREATE、PAINT、DESTROY；要重载几个函数OnInit、ERASEBKGRND、OnDraw
自定义的view类要有OSG的接口对象，在响应消息和重载函数时，通过自定义的OSG接口类OSGObject的对象在各个view函数中进行osg操作
自定义的view类要有个线程的句柄，负责每帧绘制
OSGObject的绘制函数Render里面开始while循环进行绘制，退出while循环后endthread

view类OnCreate时新建一个OSGObject的对象
view类OnInitialUpdate时启动线程，线程的函数是OSGObject的每帧绘制函数Render
渲染的时候view类调用OnDraw时，使用了mfc的默认内容没有修改，好像没有osg相关内容
结束的时候view类的OnDestroy函数中一方面销毁OSGObject对象，还要waitForSingleObject(线程句柄)

# 第三讲 VPB用法详解与问题处理
VPB是提前生成地形的
使用命令osgdem -t可以附加纹理 -d可以附加dem，-l可以指定级别 -o可以指定输出文件 --geocentric使用地形坐标系  -v高度的放大系数
可以把dem地形和纹理生成一个ive文件

常见故障
1 生成的地形有黑边
根本原因 高程比纹理覆盖的尺寸大
人为原因 截取高程和纹理时不精确
解决办法 截取时输入整数，减少高程到贴图的坐标变换的次数
尽量从大到小地切，不要从小图拼大图
2 相邻地形有缝
解决办法，截取地形时提高精度
3 无法运行osgdem，调整以下显卡选项参数，比如禁止mipmap

srtm30plus_stripped.tiff听说googleEarth就使用了这个高程， 1.73G，43200乘以21600，数据精度可能只有几百米，但是据说插值到几级都不会坑坑挖挖的。不像有些图精度虽然到了30米，但是海拔数据是一条线一条线的。不知道原图是什么坐标系的，这个高程有可能10几层
global.tiff是一个纹理图片 100Mb，21600乘以10800已经要处理为地心坐标系

如果加入shape文件还可以做海岸线、森林、建筑物等


# 第四讲 高清影像获取处理与高精度地形的生成
https://www.osgeo.cn/osgearth/data.html 讲了一系列资源
## 高程地形的获取
30m精度
http://www.gdem.aster.ersdac.or.jp
http://datamirror.csdb.cn/index.jsp
http://download.osgeo.org/ossim/data/elevation  就是那个srtm30plus_stripped.tiff  俄勒冈大学的，有好多东东 有个osgeo-live，不知道是什么
https://www.zhihu.com/question/264308418
[地理空间数据云 (gscloud.cn)](http://www.gscloud.cn/#page2)  有SRTMDEM和GDEM30m

### 查看地形的程序
globalMapper和erdas

用globalMapper来查看下载的dem是不是一个彩色的地形
用erdas来把dem转化输出成geotiff格式的影像文件，扩展名img，用globalMapper按光栅数据(即不需要海拔数据)来打开img影像文件并放大到像素级根据比例尺来确定是不是30m精度

## 纹理的获取
纹理很重要，地形不好可以用纹理来覆盖
纹理是从像googleEARTH这样的程序中截取出来的，使用的软件有
稻歌Daogle google map downloader
阿凯日www.arceyes.com
选择截图的经纬度范围，选择截取的LOD级别，软件开始自动截屏，
稻歌的问题是地图只有LOD17而选择了截取18级时，18级都是黑色的图片
阿凯日更改了这个缺点，18级没有地理信息时用17级的图片代替
导出的时候可以选择单张大图

## 纹理的处理
### 切割
### 校正
### 拼接

切割、拼接、校正、重新投影可以使用gdal命令，
gdalwarp，参数有设置坐标系，插值的重采样方法，经纬度范围，把那个srtm30plus_stripped.tiff选取了某个范围输出成一个小的tiff例子是10934.tif，用globalMapper可以查看彩色图像确实是一个小范围的高程图像。

校正的意思是给纹理(光栅图像)加入一个坐标系统，即经纬度的地心坐标系
可以使用gdalwarp，命令行的方法
可以使用globalMapper，把光栅纹理文件(那个乱画的dem.tif)拖到globalMapper窗口，此时会提示图片没有坐标系统，手动为其指定图片四个角点的经纬度坐标，再按照光栅格式输出geotiff，24位rgb格式，这样生成的光栅纹理图片dem-g.tif就有坐标系统了。这个过程好像也可以用“校正影像”功能来操作。

如果是同一经纬度范围的dem图片和纹理图片，预览时可以发现高宽比都一致了。dem图片和纹理图片都是geotiff格式的

可以把刚才的纹理用osgdem生成ive文件，再用osgviewer来观看，确实是一个有纹理的地球了

高程文件一般都是有坐标系统的。但大部分高程geotiff文件已经被投影为UTF平面坐标系了
用erdas的“Data Preparation”的“Reproject Image”来进行坐标转换和插值。
用“subset Image”功能进行切割时可以看到原来的坐标系统

拼接可以使用erdas的“mosiac Image”，也可以使用gdalwarp
可以买本erdas的书

拼接
使用阿凯日下载的大范围全LOD的图片，可以从中选取一部分经纬度一部分LOD的图片，导出为瓦片图或多张大图，输出为tif，包含经纬度坐标
发现17级的地图tif文件的尺寸太大，就用erdas切割一下，生成合适大小的纹理图片。

最后用osgdem把切割的纹理图片，高程图片，生成一个ive

# 第五讲 osgEarth主要功能
实时生成地形
矢量图渲染的很好
生成数字城市
地形文件调度
实用工具

分析一下test文件夹里面几个典型例子
earth文件的arcgisonline.earth
连接一个ESRI ArcGIS Server
从`<url>`的地址取地图
如果没有地图数据，就显示`<nodata_image>`键对应的图片
用osgearth_viewerd.exe加载这个earth文件就在控制台窗口显示地球的球形和卫星图片了。

Transportation部分显示的是道路，道路可以随着比例尺变化而减少或增多
几个`<ArcGISServerImage>`即显示了几个叠加在一起的纹理

另外
这个server的地图果然很牛 "https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/"

里面的中国卫星图很清晰 “https://www.arcgis.com/home/webmap/viewer.html?url=https%3A%2F%2Fservices.arcgisonline.com%2Farcgis%2Frest%2Fservices%2FWorld_Imagery%2FMapServer&source=sd”

视频里讲到option里面还可以设置utm投影把地形和图片投影为平面，就像boston_projected.earth

## earth文件的boston.earth
用shp文件描绘了城区的建筑外形和纹理和道路，城区可以有几个LOD级别
还用shp文件描绘了一些可以重复的组件，比如路灯，路，树，也可以随着视点拉近而显示，随视点变远而隐藏
这些shp文件好像也是从服务器下载的，用css文件控制显示风格，用js脚本控制一些街道的矢量绘制

视频中feature-geom.earth文件用world.tif作为底图，用一个shp文件作为矢量地图，美国州界线，类似feature_boundary.earth里使用shp作为国界线
视频中feature_inline_geom.earth文件绘制了两片有颜色的区域，只是定义了四个点。
视频中feature-label.earth文件定义了很多文字，文字来源于shp文件的某个字段属性
feature_models.earth和feature_model_scatter.earth文件定义了在地球上某个位置放置一个osg模型

# 第六讲 搭建脱机地球

## 使用VPB 
提前生成文件，调度快，计算负担小，硬盘空间占用大
## 使用osgEarth
地形随视点动态生成，调度慢，计算负担大，硬盘空间占用小
步骤
### 编辑earth文件
earth文件本质上是一个xml，描述了地图以及怎么使用地图
地图类型(地心或投影)
数据源，图像，高程，矢量，模型
数据的缓存位置
3.3的帮助文档说，osgEarth使用了Map/Layer范式来组织数据，Map包括一系列的layer，这些layer依次被绘制和显示。不同的类型的layer有光栅数据、矢量数据、附加层

Layer，所有层都有一些公共属性name、enabled、attribution、cache_policy、shader、proxy
file:///D:/source/osgearth-osgearth-3.3-osg-by-vcpkg/docs/html/md_source_layer.html

visible layer继承于layer，负责描述所有可见的东西

Tile Layer (common)继承于visible layer，绘制imagery或elevation

Elevation Layer继承于tile layer，绘制分片的高度数据。通常具有Elevation的后缀，有两个属性 
例如GDALElevation、TMSElevation
Image Layer继承于tile layer，在地球上绘制分片图片，具有Image后缀，有几个属性。
例如GDALImage、TMSImage



https://www.osgeo.cn/osgearth/references/earthfile.html详细列表讲了3.0.0的earth文件
的map字段的属性


map字段的属性
子字段有viewpoints、Annotations、options、ArcGISServerImage、TMSImage、TMSElevation、TFSFeatures、FeatureModel、bumpmap、XYZFeatures、SplatImage、detail、Model、GDALImage、GDALDEM、GDALElevation、GARSGraticule、MGRSGraticule、GeodeticGraticule、MapBoxGLImage、MBTilesImage、WMSImage、Ocean、TFSFeatures、RoadSurface、libraries、SplatImage、GroundCover、Wind、SplatImage、Grass、CompositeLandCover、OGRFeatures可以作为map的子字段，也可以作为FeatureModel的子字段、

下载纹理和高程，校正纹理四个角点的坐标


编写earth文件

标签map 标签image

如何解决动态生成负担大调度慢的问题，使用标签option的子标签cache，类型为fi lesystem

新建一个earth文件使用了map标签

1 earth文件定义好之后，就从代码中访问它，把`COSGObject::InitSceneGraph`的`osg::readNodeFile`的参数改为earth文件

第一次运行的时候，要生成cache文件，所以加载osg窗口的时候非常慢

第二次运行的时候就很快了，因为缓存已经生成
所以使用osgearth cache预先生成缓存文 件，放到earth文件同级目录下

2 使用skyNode类加入地球背景后面的日月星辰

新定义一个`COSGObject::InitOsgEarth`函数
在里面新定义了一个Manipulator，其node为earth文件的节点
新定义了一个天空，可以设置日期时间，viewer，亮度

# 第七讲 省界和国界
1资源可以在网上下载shp文件
2可以按照矢量线或栅格化方式来进行显示，栅格化的形式可以通过每个level都生成缓存，来达到近似于矢量效果
栅格图的线与周围的图片融合较好，所以使用栅格，image标签，并用osgearth_cache制造缓存文件
3本节先试一下栅格化在earth文件中

矢量的标签是model

栅格化的标签是image，使用agglite驱动把shp文件进行栅格化。feature的子标签里处理透明度、把矢量栅格化为点或线或面之类的信息，以及风格的style

栅格化之后，依然要用osgearth_cache为栅格化的图片生成缓存，

4如何在程序中代码控制图层，来实现隐藏国界线的栅格图层

节点图
MapNode根节点
|
-----------------------------------
|                 |                                |
Map    ModelLayer建筑矢量   OverlayLayer投影
|
----------------------------------------------------------
|                                  |                                               |
ImageLayer影像     ElavationLayer高程        ModelLayer建筑矢量
|
ImageLayerOption

在ImageLayeroption里面可以设置图层的 各个属性

因此在代码中定义两个指针MapNode、ImageLayer,

其中ImageLayer可以通过earth文件里的im age标签的图层名字来获取mapNode-＞getMa p->getImageLayerByName

然后就可以用一些函数来对ImageLayer进行设置了，设置透明度等

I 问题1

高程图和影像图都是tif格式，怎么判断到底是哪种


# 第八讲 解决资源争抢问题
 问题的原因是渲染函数中，在遍历某个容器时，另一个线程删除了容器的某个元素，导致第一个线程的容器的iterator出现了问题。也就是没有对场景树进行mutex保护。
解决办法一，修改场景树时，一定要在处理event或处理update的回调中进行。切勿在渲染中修改场景树。但是作者觉得麻烦。
解决办法二，渲染在一个线程A，响应菜单在另一个线程B。菜单线程B开始处理按钮事件前触发一个信号，阻止渲染线程进行；菜单线程B完成该UI事件后重置信号，允许渲染线程进行。

# 第九讲 镜头拉近就死机
debug模式下镜头从远处向地球某处拉近，就会崩溃发生unhandled exception，发现是geos.dll出了问题
发现是cmake编译osgearth时debug模式用错了geos的lib
修改办法，重新编译geos的debug的lib，重新编译osgearth的debug

# 第十讲 在地球上增补超清影像
第一步 从googleEarth上截取纹理
第二步 使用osgdem生成中间文件geotif，进行纹理校正，因为第一步下载的图片坐标需要变换
第三步 把中间文件放在osgEarth上，使用earth文件的composite标签添加复合影像。为什么不使用两个image呢，因为两个image的相邻图片中间有缝。如果使用composite的话，会自动把两个相邻图片融合，消除缝。第二个原因是顶层的image有数量限制
因此要是有影像复合，就必须使用composite标签

第一步 谷歌卫星地图下载器 
下载一个范围的17级图像，导出多张大图，行列数均是2的幂，导出格式为geotif
此时图片非常多，文件夹操作会非常费时间，所以文件夹的命名等，要十分规范，比如“13-经度起止-维度起止”
第二步 把下载的geotif文件生成中间文件，使用"osgdem -t 源文件名 -geocentric -l 1 -o output.ive"
这个命令会生成中间文件geotif，然后再进行后续我们不需要的过程，因为我们只需要这个中间geotif文件即可，所以只要osgdem输出了geotif，就可以control+C停止。再给这些文件重命名规律的名
第三步 打开earth文件，高程文件不用动，只需添加新的局部高清纹理。所以把新成生的geotif文件使用两层image标签添加，外层image的drive使用composite，里层的image是每个地图，driver使用gdal。而且13L的顺序要在17L的前面，这样才能使得下面的高清能覆盖上面低清的
第四步 生成cache。要点是一级一级生成，这样有了错误可以及时处理。
osgEarth_cache --seed 源文件.earth --min-level 1 --max-level 3
osgEarth_cache --seed 源文件.earth --bounds  西 南 东 北  --min-level 1 --max-level 5
osgEarth_cache --seed 源文件.earth --bounds  局部西 局部南 局部东 局部北  --min-level 1 --max-level7
同样方法接下来还可以继续生成同范围level7到level10的cache

# 第十一讲 添加地名
使用类PlaceNode添加地名的文本和图标，它是osgEarth::Annotation的子节点，继承于osg::Switch
在COSGObject类中添加osg::Group的成员变量，作为所有地标的父节点。
添加成员函数addLabel添加地标，用位置、图片、文字来初始化一个PlaceNode
为了显示中文，还把osgEarth的源代码annotation和placeNode添加了wstring相关部分

# 第十二讲 全国地名的显示
用LOD来控制显示几级地名，地名不能太拥挤，
数据来源于kmz文件，解压完成后是kml文件，实际是xml
规定了地名从哪个LOD级别开始显示，规定了地名的区域，规定了省会城市的icon图标，颜色，字的中心点

把这个kmz文件转存为txt，并删除了很多内容，把文件字符码由utf8转为ascii

为了解决文字挤在一起，用LOD的办法解决，kmz文件中已经给出了每个文字在哪个级别显示，问题就在于怎么根据眼睛到文字的距离来人物设定当前距离属于哪个级别，如果符合kmz文件中读出的级别，就显示这个文字

用fstream读入文字和坐标，把经纬度坐标转为xyz坐标，
然后建立lod节点，设置用户中心模式，设置文字的xyz坐标为lod的中心坐标setCenter
当视点与当前lod节点中心的距离属于用户预先设置的某个级别时，就控制lod

再加上图标，

但是程序读取陕西的西安地名并建立lod节点就用了1分钟，速度太慢了。

# 第十三讲 海量地名效率问题解决
后台建立线程读取地名，读取一部分就显示一部分。

# 第十四讲 全国地名终极解决方案
十三讲使用的多线程办法不容易实现多线程下保护场景树根节点
最终还是决定使用PagedLOD，需要渲染时再读进来，不显示的时候移出内存

把txt文件用一个线程读进来，存储为两类文件
一个是把txt文件中读出的文本、中心位置、等信息变成osgEarth::Annotation::PlaceNode节点，每个节点存储为一个ive文件
一个是把各个label的中心点位置和范围存储到一个文本文件，所有label的属性存在一个文件里，因为这些属性是建立LOD节点是所需要的，但是ive里面没有这些信息

然后把这两个文件读出来，读出来的ive建一个PagedLOD类对象，类的中心和范围属性从txt文件中读取。

程序运行的时候，只要视点进入范围，就会从启用已经在场景树中的pagedLOD对象，虽然这些对象数量级为万，但是lod切换的时间很短

# 第十五讲 shape文件的编辑
用arcview程序编辑shape文件，这里记录了矢量文件
一个shp文件还附带着dbf、prj文件
一个shp文件里面只有一种几何元素，如点，线，多边形
手动编辑的shp文件，加了几个几何图形，加了几个文字属性放在dbf文件中。如果想在osgEarth中正确显示，还需要有prj文件，即投影方式。使用feature＿geometry.ea rth文件可以显示图形

# 第十六讲 shape文件的读取 
OGR读取shp文件，建立一个FeatureSource节点，其有若干个feature，每个feature有osgEarth::geometry和几何类型信息，以及attr信息，attr信息可以转化为string或double。
include osgEarthFeatures/FeatureSource, osgEarthDrivers/feature_ogr/OGRFeatureoptions

新建osgEarth::Drivers::OGRFeatureOptions来包含输入文件的url
使用osgEarth::Features::FeatureSourceFactory::create()新建osgEarth::Features::FeatureSource

然后就可以从osgEarth::Features::FeatureSource中遍历取出各个osgEarth::Features::Feature

再从osgEarth::Features::Feature中读出几何geometry、几何类型type、属性attr 。

如果想只取出特定信息，可以使用osgEarth::Symbology::Query的expression寻找某属性为某个值的那条feature

# 第十七讲 shape多边形的渲染与控制
几种渲染方法
一 把点练成多边形
首先要解析osgEarth::Features::Feature里面的多边形类型，是否为环，或者包含多个多边形
因此用osgEarth::Symbology::GeometryIterator来遍历osgEarth::Features::Feature的getGeometry
单个多边形实例为osgEarth::Symbology::Geometry，里面的顶点可以变换为osg::Vec3Array，添加到osg::Geometry里面就可以绘制了
但是这样简单渲染的是平面的图像，不是球形的。估计shp里面的坐标是经纬度的，要使用osgEarth::ECEF::transformAndLocalize函数来把坐标转换为球形的。

怎么把线渲染成面
直接对osg::Geometry用了osgUtil::Tesselator的retessellatePolygons，就把顶点集合细分为多边形了。
怎么把面再渲染在球体上
读入一个osgEarth文件，付给一个osg::Node，再把它加入到一个osg::Group
把earth文件的osg::Node转化为osgEarth::MapNode，获得其getOverlayGroup，把shp文件的osg::Geode加入，再调用updateOverlayGraph。然后正常执行viewer的循环
重点是MapNode的getOverlayGroup与updateOverlayGroup


但是出现了一个小瑕疵，shp文件的多边形有几处出现了两个多边形形状重合的问题，比如一个红色中国与绿色蒙古各有一部分叠加产生了一块黄色区域。解决办法是在earth文件中关闭overlay层的透明度，这样就没有混合效果了``` <overlay_blending>false</overlay_blending>```

# 第十八讲 shape多边形的点选高亮
思路 
1把多边形输出到文件，并将其中每个多边形命名为world
2使用该文件overlay到地球上
3鼠标点击时判断点到了哪个多边形
4改变这个多边形的颜色，并恢复上一次点击的多边形颜色
5重新将改变后的多边形overlay到地球上

场景树的根是一个osg::Group
每个国家是一个osg::Geode，名字为world。多边形是一个osg::Geom，名字为国家名。
遍历全部国家后使用osgDB::Registry::Instance::writeNode把这个场景树的根节点osg::Group输出
现在这个输出的ive就是所有国家形状多边形围成的球形

读入这个ive文件，加入MapNode的overlayGroup

建立一个eventHandler类，在handle函数中处理鼠标双击事件，使用类osgViewer::Viewer::ComputeIntersections来计算鼠标点所在的直线与场景viewer的相交情况，并把结果保存在osgUtil::LineSegment::Intersector::Intersections中。
遍历结果集，调用osgUtil::LineSegmentIntersector::Intersections::iterator->getWorldIntersectPoint获得交点，使用mapNode->getMap->worldPointToMapPoint获得交点的经纬度
连接地球球心也就是000与这个交点建立一条直线osgUtil::LineSegmentIntersector，判断这条线段与多边形的交点mapNode->accept(osgUtil::IntersectionVisotor)，如果交点的名字是world，则线段与国家多边形相交。再改变这个交点多边形的颜色即可。

# 第十九讲 shape多边形高亮的菜单控制
上节课初步完成了功能，这节课把这些功能集成到菜单里面
主要是MFC

# 第二十讲 等高线
使用globalMapper把一个高程tif生成等高线文件，打开tif后选择一些设置，延长网络，选择好单位，生成等高线，然后输出矢量格式shape文件
读入shape文件，建立osg::Geom为line_strip模式，把节点转存为ive
再在工程中读入该ive文件即可，但是看效果不是很好，没有lod效果，加载很慢，视点移动也很慢

# 第二十一讲 鼠标与地形交点的信息显示
用`osgEarth::Util::Controls::ControlCanvas`创建一个面板，添加到场景树的根节点，然后各种按钮，label作为该面板的子节点。详见8:31'左右
用`osgEarth::Util::Controls::LabelControl`创建按钮，详见26:46'左右
鼠标与地形的交点使用eventHandler，详见25:10'、28:06'
视点类是把`osgViewer::Viewer`的`getManipulator`转化为`osgEarth::Util::EarthManipulator`的实例，就可以用`getViewpoint`方法获取视点的绝对位置经纬高，这个高应该是getRange返回视点离地高度

# 第二十二讲 osg控件支持中文
核心办法是修改osgEarth的源代码
osgEarth::Util::Controls::LabelControl的构造函数和setText、getText、calcSize新加一个wstring版本的，成员变量新加一个wstring的，其他函数中出现_text的要查看一下是否要修改

# 第二十三讲 视点飞行动画
使用类`osgEarth::Util::EarthManipulator`的`setViewpoint`来控制视点的位置姿态，和时间，
osgEarth自动进行动画过渡。viewpoint是一个有位置姿态的类，位置和姿态用`osgEarth::Viewpoint`类的getFocalPoint函数来获得，姿态用getHeading、getPitch来获得，getRange获得的感觉是离地高度。
也可以只进行每帧的视点位置姿态控制
但是要注意类`osgEarth::Util::EarthManipulator`的setNode函数只能包含从earth文件读出的mapNode节点，不能包括云，天，城市，车辆。否则manipulator的运动控制就不正常。

# 第二十四讲 地表放置飞机汽车等物体
场景树为，MatrixTransform->Node
那MatrixTransform的矩阵怎么获得，用
```
CoordinateSystemNode->getEllipsoidModel->computeLocalToWorldTransformFromLatLongHeight
```
从经纬高获得世界的xyz，但是不知道姿态是怎么在这里求出来的，最终机场模型与地图也没有符合。

# 第二十五讲 飞机沿着设置路径飞行及跟踪飞行物
外界输入一些控制点，每个点包含飞机的经纬高位置和速度，让飞机沿路径飞行

做法为把这些控制点生成一个osg::AnimationPath

飞机的经纬高位置来自关键点的位置
飞机的姿态要根据前后两帧的xyz位置计算，只计算h和p，不计算roll。
求一个节点的变换矩阵可以使用
```
csn->getEllipsoidModel->computeLocalToWorldTransformFromLatLongHeight
```

根据经纬高求变换矩阵

第一个点的时间为0，后续点的时间根据预定的速度跑完两帧之间的距离来求。

然后把每个控制点添加到
```
osg::AnimationPath->insert(时间，osg::AnimationPath::ControlPoint(位置，姿态矩阵))
```

让飞机的osg::Node飞这个动画路径
给飞机的osg::MatrixTransform增加一个updateCallback(new osg::AnimationPathCallback(osg::AnimationPath,0,1))就可以了

跟踪使用Manipulator的setTetherNode(节点)

# 第二十六讲 粒子尾流
FireEffect给飞机添加尾迹
`osgParticle::FireEffect`作为飞机的`MatrixTransform`的子节点，设置其`setUseLocalParticleSystem`为false了。

# 第二十七讲 彩带尾迹
飞机后面画一条颜色的矩形，使用`updateCallback`不停地更新矩形的位置姿态使其维持在飞机尾部，把旧的矩形擦除

`class myCallback`继承于`osg::NodeCallback`，成员有一个```osg::observer_ptr<osg::Geometry> _ribbon```
`osg::observer_ptr`于`osg::ref_ptr`相比，可以知道本指针是不是valid
在operator函数中，更新点的坐标

# 第二十八讲 飞行参数的获取与显示
在界面上建立一个`osgEarth::Util::Controls::LabelControl`显示文本
在`osgEarth::Util::Controls::LabelControl`的`EventHandler`类的handle函数里面响应frame事件，更新文本，飞机的位置需要从某个`MatrixTransform`中获得，获得的当然是xyz，需要再使用`mapNode->getMap->worldPointToMapPoint`来得到经纬高

# 第二十九讲 飞机之间切换

# 第三十讲 测量两点间路程
求出起点和终点的经纬高。
把两点连线进行细分，每段细分线在考虑到海拔差异时就可以计算出路程。
这是一个略微简单的算法
起点和终点画球，更明显，两点连线，便于观察。

#  第三十一讲 视野切换到地表时太黑的问题
用`osgGA::StateSetManipulator`来解决问题，把它添加到`mViewer`的`EventHandler`，顺序要先添加`osgGA::StateSetManipulator`再添加`osgGA::EventHandler`
然后`osgGA::StateSetManipulator`调用`setLightingEnable`为false，可能意思就是关闭灯光，只显示贴图或材质。但是为什么飞机又变成白色了呢。
飞机要`getOrCreateStateSet`，设置`GL_LIGHTING`为`StateAttribute::ON`和`PROTECTED`

# 第三十二讲 添加飞往常用地点按钮及点线面模式
点线面模式就是调用`osgGA::StateSetManipulator`的`setPolygonMode`
添加常用地点按钮就是调用`earthManipulator`的`setViewpoint`

# 第三十三讲 红蓝立体显示
`osg::DisplaySettings`可以设置立体方式，`osg::DisplaySettings::instance()`的`setStereo(true)`

# 第三十四讲 指南针
指针始终朝北，表盘随鼠标转动
用`osgEarth::Manipulator`类的`getViewpoint`函数来查询三个角度，在`eventHandler`里面更新表盘
绘制一个hud的geode，注意表盘和指针要按顺序加到父节点

# 第三十五讲 俯视缩略图以及高亮显示飞机与机场
缩略图时用一个俯视HUD相机，观察矩阵是实时改变的，它的center一直是地心，位置的xy随着观察者改变，位置的高度不变。
机场在缩略图上使用`osgEarth::Annotation::PlaceNode`来表示