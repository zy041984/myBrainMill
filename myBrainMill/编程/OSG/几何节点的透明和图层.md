# 版本
osg3.6.5 GL2,不使用shader
## 图层
图层按照顺序渲染，不同的图层可以互相遮盖，改变图层顺序可以改变互相的遮盖关系

TRANSPARENT_BIN是按照深度来绘制
OPAQUE_BIN是按照状态树来排序绘制

假设所有的图层的drawable深度值都相同。
可以使用OPAQUE_BIN，把不同的图层设置为不同的状态树，但是这样带来了多余的状态树节点。
也可以使用TRANSPARENT_BIN，所有的drawable或geode设置相同的状态树，把一个图层位于一个group，不同的图层就是sceneGraph上不同的group节点，调整sceneGraph的节点位置就会改变渲染顺序，形成遮挡关系

## 透明
核心算法就是fs的输出与帧缓存中已有的进行混合
要设置BlendEquation和BlendFunc才有透明度效果，

alpha值小于1的drawable与alpha值等于1的drawable的绘制顺序不同，最终的图片也不同
- 先绘制不透明物体，再绘制透明物体，最终效果就是不透明物体上面盖了层透明玻璃一样
- 先绘制透明物体，再绘制不透明物体，最终效果就像是不透明物体压住了透明玻璃一样

由于所有图形深度相同，只要正确设置状态树，transparent和opaque都有同样的透明度效果
- geode的状态树只设置深度，alpha值小于1的geode取消深度缓存即可，alpha值等于1的geode可以有深度缓存
- geom的状态树只设置blend，所有参与blend的geom都要设置同样的blend，不能只给玻璃geom设置blend。这个要求对于transparent和opaque是一样的，

可以把所有drawable放在同一个geode里，也可以把透明的drawable单独放在一个geode，不透明的drawble放在另一个geode

//状态树 
//root有深度
	//geode有深度
		//两个三角drawable红和蓝使用一个stateSet关闭光照设置混合
	//geode取消深度，
		//一个三角drawable绿使用相同stateset关闭光照设置混合
	//geode取消深度，
		//两个三角drawable绿使用stateset关闭光照设置混合设置贴图
//renderBIN 五个drawable都相同	

//OPAQUE_BIN是按照状态树来排序绘制
//则先排列状态树，再状态树内按照顺序渲染
//根据两个geode的顺序要么绿压红蓝，要么红蓝压绿，红蓝的顺序可以根据在geode内部的顺序改变，绿色透明

//TRANSPARENT_BIN是按照深度来绘制
//结果同OPAQUE_BIN
## 贴图
使用modulate模式的贴图模式把纹理绘制在白色三角形上。
状态要有blendEqu和blendFunc和texEnv，并且使用TRANSPARENT_BIN
图层和透明的结论类似普通Geode节点
## renderBinNum
为了在代码中控制渲染顺序，可以再设置group父节点，其stateSet只有renderBinNum，可以在代码中动态修改
```
//不能使用shader osg3.6.5-GL2
//测试2 透明度
//要设置BlendEquation和BlendFunc才有透明度效果,
//核心算法就是fs的输出与帧缓存中已有的进行混合

//alpha值小于1的drawable与alpha值等于1的drawable的绘制顺序不同,最终的图片也不同
  //先绘制不透明物体,再绘制透明物体,最终效果就是不透明物体上面盖了层透明玻璃一样
  //先绘制透明物体,再绘制不透明物体,最终效果就像是不透明物体压住了透明玻璃一样

//由于所有图形深度相同,只要正确设置状态树,transparent和opaque都有同样的透明度效果
  //geode的状态树只设置深度,alpha值小于1的geode取消深度缓存即可,alpha值等于1的geode可以有深度
  //geom的状态树只设置blend,所有参与blend的geom都要设置同样的blend,不能只给玻璃geom设置blend。这个要求对于transparent和opaque是一样的,

//可以把所有drawable放在同一个geode里,也可以把透明的drawable单独放在一个geode,不透明的drawble放在另一个geode

//状态树 
//root有深度
	//group设置renderBinNum=0，设置renderBin为OPAQUE_BIN或TRANSPARENT
		//geode有深度
			//两个三角drawable红和蓝alpha=1使用一个stateSet关闭光照设置混合
	//group设置renderBinNum=1，设置renderBin为OPAQUE_BIN 
		//geode取消深度,
			//一个三角drawable绿alpha!=1使用相同stateset关闭光照设置混合
	//group设置renderBinNum=2，设置renderBin为OPAQUE_BIN 
		//geode取消深度,
			//两个三角drawable白alpha!=1使用相同stateset关闭光照设置混合有贴图，模式为MODULATE
// 五个drawable的stateSet里设置了相同的	renderBIN为OPAQUEBIN或TRANSPARENT
// 三个group的stateSet里设置了相同的renderBIN

//OPAQUE_BIN是按照状态树来排序绘制
//则先排列状态树,再状态树内按照顺序渲染
//根据两个geode的顺序要么绿压红蓝,要么红蓝压绿,红蓝的顺序可以根据在geode内部的顺序改变,绿色透明

//TRANSPARENT_BIN是按照深度来绘制
//旧的geom是三条直线形成坐标轴,这个geom的深度可能更远 
//无论geode的顺序怎样,两个三角都压直线,只是两个三角的顺序可以根据在geode内部的顺序改变
//可能是三条直线的平均深度更远,
//改成一条XOZ平面的直线,则geode在root中的顺序可以影响渲染顺序了,有时候两个三角压直线,有时候直线压两个三角
//本测试中改成三个深度均相同的三角形geom,结果同OPAQUE_BIN
// 
//DEFAULT_BIN好像跟OPAQUE_BIN相同

//对于贴图，以上结论相同。
//贴图可以设置TexEnv模式为modulate，使得fs输出为贴图各分量与顶点颜色各分量相乘。
//设置顶点颜色的alpha即可以改变显示的透明度效果，设置顶点颜色的RGB可以改变贴图的色调

//TRANSPARENT_BIN是按照深度来绘制//OPAQUE_BIN是按照状态树来排序绘制
//axisStateset->setRenderingHint(osg::StateSet::TRANSPARENT_BIN);//DEFAULT_BIN//TRANSPARENT_BIN
triangleStateset->setRenderingHint(osg::StateSet::OPAQUE_BIN);//OPAQUE_BIN
myRoot->setStateSet(rootStateSet);// rootStateSet);//开启深度测试
myGeod->setStateSet(rootStateSet);//开启深度测试
myGeodTriangle1->setStateSet(geodeStateSet);//关闭深度geodeStateSet
myGeodTriangle2->setStateSet(geodeStateSet);//关闭深度geodeStateSet

osg::BlendEquation* blendEquation = new osg::BlendEquation(osg::BlendEquation::FUNC_ADD);
blendEquation->setDataVariance(osg::Object::DYNAMIC);
triangleStateset->setAttributeAndModes(blendEquation, osg::StateAttribute::ON);
osg::BlendFunc* blendFunction = new osg::BlendFunc(osg::BlendFunc::SRC_ALPHA, osg::BlendFunc::ONE_MINUS_SRC_ALPHA);
blendFunction->setDataVariance(osg::Object::DYNAMIC);
triangleStateset->setAttributeAndModes(blendFunction, osg::StateAttribute::ON);

texStateSet->setRenderingHint(osg::StateSet::OPAQUE_BIN);
texStateSet->setAttributeAndModes(blendEquation, osg::StateAttribute::ON);
texStateSet->setAttributeAndModes(blendFunction, osg::StateAttribute::ON);

axisGeom->setStateSet(triangleStateset);//一个状态树关闭光照打开混合
triangle1Geom->setStateSet(triangleStateset);//一个状态树关闭光照打开混合
triangle2Geom->setStateSet(triangleStateset);//一个状态树关闭光照打开混合
triangle3Geom->setStateSet(texStateSet);//一个状态树关闭光照打开混合设置贴图
triangle4Geom->setStateSet(texStateSet);//一个状态树关闭光照打开混合设置贴图
myGeodTriangle1->addDrawable(triangle1Geom);//green0 1 0 0.21
myGeod->addDrawable(axisGeom);//rgba1 0 0 1
myGeod->addDrawable(triangle2Geom);//rgba0 0 1 1
myGeodTriangle2->addDrawable(triangle3Geom);//左上
myGeodTriangle2->addDrawable(triangle4Geom);//右下

osg::ref_ptr<osg::Group> line = new osg::Group;
line->addChild(myGeod);
osg::ref_ptr<osg::Group> tri = new osg::Group;
tri->addChild(myGeodTriangle1);
osg::ref_ptr<osg::Group> tex = new osg::Group;
tex->addChild(myGeodTriangle2);
//改变sceneGraph节点的顺序可以改变遮挡关系
myRoot->addChild(tri);
myRoot->addChild(tex);
myRoot->addChild(line);

//或者用renderBINNum来确定绘制顺序，把这个stateSet放在geode父级的Group节点上
osg::StateSet* bin0 = new osg::StateSet;
bin0->setRenderBinDetails(0, "DepthSortedBin", osg::StateSet::USE_RENDERBIN_DETAILS);//RenderBin=OPAQUE//DepthSortedBin=TRANSPARENT
osg::StateSet* bin1 = new osg::StateSet;
bin1->setRenderBinDetails(1, "DepthSortedBin", osg::StateSet::USE_RENDERBIN_DETAILS);
osg::StateSet* bin2 = new osg::StateSet;
bin2->setRenderBinDetails(2, "DepthSortedBin", osg::StateSet::USE_RENDERBIN_DETAILS);
line->setStateSet(bin0);//line为红蓝triangle
tex->setStateSet(bin1);//tex为贴图
tri->setStateSet(bin2);//tri为绿triangle
```


//旧的geom是三条直线形成坐标轴，这个geom的深度可能更远 
//无论geode的顺序怎样，两个三角都压直线，只是两个三角的顺序可以根据在geode内部的顺序改变
//可能是三条直线的平均深度更远，
//改成一条XOZ平面的直线，则geode在root中的顺序可以影响渲染顺序了，有时候两个三角压直线，有时候直线压两个三角
//本测试中改成三个深度均相同的三角形geom，
# 版本
osg3.6.5 GLCore,使用vs和fs