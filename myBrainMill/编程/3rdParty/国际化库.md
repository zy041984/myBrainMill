度数用了ASCII扩展`0xB0`表示度数符号,deepseek说它的UTF8编码是`0xC2 0xB0`
用c++代码转码如下
```
#include <iostream>
#include <string>
#include <locale>
#include <codecvt>

int main() {
    // 原始字节（ISO-8859-1编码的0xB0）
    char latin1_char = '\xB0'; 

    // 转换为宽字符（Unicode码点）
    std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
    wchar_t wide_char = static_cast<wchar_t>(latin1_char & 0xFF);

    // 转换为UTF-8
    std::string utf8_str = converter.to_bytes(wide_char);

    // 输出UTF-8编码的十六进制
    std::cout << "UTF-8 Bytes: ";
    for (unsigned char c : utf8_str) {
        std::cout << std::hex << static_cast<int>(c) << " ";
    }
    std::cout << std::endl;  // 输出：c2 b0

    return 0;
}
```
`<codecvt>`在C++17中被标记为废弃，建议使用第三方库（如`iconv`或`ICU`）

使用ICU的代码
```
#include <unicode/ucnv.h>
#include <unicode/unistr.h>
#include <iostream>

int main() {
	u_setDataDirectory("D:\\download\\SrcBuild\\ICU76.1\\icu-release-76-1\\icu4c\\bin64\\Debug");//要把icudt76l.dat文件放在这里
    //莫的gbk编码c4 aa，莫的UTF8 E8 8E AB
int i1 = 0xc4;
int i2 = 0xaa;
std::string gbkStr(2, '0');
memset(const_cast<char*>(gbkStr.data()), 0, gbkStr.size());
memcpy_s(const_cast<char*>(gbkStr.data()), 1, &i1, 1);
memcpy_s(const_cast<char*>(gbkStr.data() + 1), 1, &i2, 1);
//std::cout << gbkStr << std::endl;
int errNum{ 0 };
std::string utf8Str;
UErrorCode err = U_ZERO_ERROR;
int32_t targetLimit = 0, sourceLimit = 0, i = 0, targetCapacity = 0;
char* target = 0;
sourceLimit = gbkStr.size();
err = U_ZERO_ERROR;
targetLimit = 0;
const char* source = gbkStr.c_str();
targetCapacity = ucnv_convert("UTF-8", "GBK", NULL, targetLimit, source, sourceLimit, &err);
if (err == U_BUFFER_OVERFLOW_ERROR)
{
	err = U_ZERO_ERROR;
	targetLimit = targetCapacity + 1;
	target = (char*)malloc(sizeof(char) * targetLimit);
	targetCapacity = ucnv_convert("utf-8", "gbk", target, targetLimit, gbkStr.c_str(), sourceLimit, &err);
	if (U_FAILURE(err))
	{
		errNum = static_cast<int>(err);
	}
	else
	{
		utf8Str.resize(targetLimit);
		memcpy_s(utf8Str.data(), utf8Str.size(), target, utf8Str.size());
		errNum = 0;
	}
}
else
{
	errNum=static_cast<int>(err);
}
}
```
使用iconv库的代码
```
#include <iconv.h>
#include <stdio.h>
#include <string.h>
int main() {
    // 输入数据（ISO-8859-1编码的0xB0）
    char input = '\xB0';
    size_t in_bytes_left = 1;
    // 输出缓冲区（UTF-8最多4字节）
    char output[4] = {0};
    size_t out_bytes_left = sizeof(output);
    // 创建转换描述符（必须声明为ISO-8859-1而非ASCII）
    iconv_t cd = iconv_open("UTF-8", "ISO-8859-1");
    if (cd == (iconv_t)-1) {
        perror("iconv_open failed");
        return 1;
    }
    // 转换参数设置（需使用指针的指针）
    char *in_ptr = &input;
    char *out_ptr = output;
    if (iconv(cd, &in_ptr, &in_bytes_left, &out_ptr, &out_bytes_left) == (size_t)-1) {
        perror("iconv failed");
        iconv_close(cd);
        return 1;
    }
    // 输出UTF-8字节序列
    printf("UTF-8 Bytes: ");
    for (size_t i = 0; i < sizeof(output) - out_bytes_left; ++i) {
        printf("%02x ", (unsigned char)output[i]);
    }
    printf("\n");  // 输出：c2 b0
    iconv_close(cd);
    return 0;
}
```
# ICU
## 编译
winrar管理员模式解压
用vs2022管理员模式打开`icu4c\source\allinone\allinone.sln`，build。有三个windows stores的项目报错，不用管了。
编译完debug之后最好新建文件夹debug保存dll和lib和pdb，因为没有给名字加后缀d。不知道怎么加，debug加了后缀d后release也有这个后缀d。
## 测试
1.把`\test\testdata`复制到`D:\download\SrcBuild`中
2.把`icu4c\source\test\cintltst\x64\Debug\cintltst.exe`复制到`D:\download\SrcBuild\ICU76.1\icu-release-76-1\icu4c\bin64`中并运行。
3.把`icu4c\source\test\intltst\x64\Debug\intltest.exe`复制到`D:\download\SrcBuild\ICU76.1\icu-release-76-1\icu4c\bin64`中并运行。
4.把`icu4c\source\test\iotest\x64\Debug\iotest.exe`复制到`D:\download\SrcBuild\ICU76.1\icu-release-76-1\icu4c\bin64`中并运行。
## 使用
bin里面的dll，include，lib给别的项目用就可以了
`stubdata`输出`icudtXYl.dll`是数据库
`common`输出`icuucXY.dll`是给别的项目用的
`i18n`输出`icuinXY.dll`是给别的项目用的，包含了许多locale的国际化函数
`io`输出`icuioXY.dll`是给别的项目用的，提供了像stdio一样的功能
`toolutil`输出`icutuXY.dll`是内部使用的，提供了ICUTools使用的一些API
`iculxXY.dll`是给别的项目使用的，提供使用ICU做段落layout，需要harfBaze，sln里面没有看到这个工程