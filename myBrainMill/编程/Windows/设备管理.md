使用CM系列函数
1.枚举系统当前的GUID
每次获得的GUID可以与已知的字符串比较。这样就能获得HID这一类设备的GUID
2.再从HID这一类设备中找出已知GUID的硬件设备，打印其属性
```
#include <windows.h>
#include <cfgmgr32.h>
	unsigned long data1{ 0x4d1e55b2 };
	unsigned long data2{ 0xf16f };
	unsigned long data3{ 0x11cf };
	std::array<unsigned char, 8> data4;
	data4[0] = static_cast<char>(0x88);
	data4[1] = static_cast<char>(0xcb);
	data4[2] = static_cast<char>(0x00);
	data4[3] = static_cast<char>(0x11);
	data4[4] = static_cast<char>(0x11);
	data4[5] = static_cast<char>(0x00);
	data4[6] = static_cast<char>(0x00);
	data4[7] = static_cast<char>(0x30);
	//枚举当前系统所有的GUID
	ULONG flags{ CM_ENUMERATE_CLASSES_INTERFACE };
	GUID hidClassGUID;//设备接口GUID
	ULONG indexClassID{ 0 };
	for (ULONG i = 0; ; i++)
	{
		GUID ClassGuid;//通过提供每个类的 GUID 来枚举本地计算机的已安装设备类
		CONFIGRET cr = CM_Enumerate_Classes(i, &ClassGuid, flags);
		if (cr != CR_SUCCESS)
			break;
		else
		{
			std::cout << " Data1-3Hex " << std::hex << ClassGuid.Data1 << " - " << ClassGuid.Data2 << " - " << ClassGuid.Data3;
			std::cout << " Data4 " << std::hex
				<< static_cast<ULONG>(ClassGuid.Data4[0])
				<< static_cast<ULONG>(ClassGuid.Data4[1])
				<< static_cast<ULONG>(ClassGuid.Data4[2])
				<< static_cast<ULONG>(ClassGuid.Data4[3])
				<< static_cast<ULONG>(ClassGuid.Data4[4])
				<< static_cast<ULONG>(ClassGuid.Data4[5])
				<< static_cast<ULONG>(ClassGuid.Data4[6])
				<< static_cast<ULONG>(ClassGuid.Data4[7]) << std::endl;
			if ((data1 == ClassGuid.Data1)
				&& (data2 == ClassGuid.Data2)
				&& (data3 == ClassGuid.Data3))
			{
				bool ok{ true };
				for (size_t j = 0; j < data4.size(); j++)
				{
					if (ClassGuid.Data4[j] != data4[j])
					{
						ok = false;
						break;
					}
				}
				if (ok)
				{
					indexClassID = i;
					hidClassGUID.Data1 = ClassGuid.Data1;
					hidClassGUID.Data2 = ClassGuid.Data2;
					hidClassGUID.Data3 = ClassGuid.Data3;
					for (int k = 0; k < 8; k++)
						hidClassGUID.Data4[k] = ClassGuid.Data4[k];
				}
				else
					continue;
			}

		}
	}
	//找到了HID的设备接口类的GUID
	ULONG buffLen{ 0 };
	ULONG flags2{ CM_GET_DEVICE_INTERFACE_LIST_PRESENT };
	//DEVINSTID_A dinstid;
	std::wstring tmp;
	CONFIGRET cr = CM_Get_Device_Interface_List_SizeW(&buffLen, &hidClassGUID, nullptr, flags2);
	if (cr != CR_SUCCESS)
	{
		std::cout << "CM_Get_Device_Interface_List_SizeA error" << std::endl;
	}
	else
	{
		std::vector<wchar_t> DeviceInterfaceList(buffLen);
		cr = CM_Get_Device_Interface_ListW(&hidClassGUID,
			nullptr, DeviceInterfaceList.data(), buffLen, flags2);
		if (cr != CR_SUCCESS)
		{
			std::cout << "CM_Get_Device_Interface_ListA error" << std::endl;
		}
		else
		{
			tmp.resize(DeviceInterfaceList.size());
			for (size_t j = 0; j < DeviceInterfaceList.size(); j++)
				tmp[j] = DeviceInterfaceList[j];
			if (tmp.find(L"HID#VID_303A&PID_0002") != std::string::npos)//std::find(DeviceInterfaceList.begin(), DeviceInterfaceList.end(), "VID_303A&PID_0002") != DeviceInterfaceList.end()
			{
				for (size_t i = 0; i < DeviceInterfaceList.size(); i++)
					std::wcout << DeviceInterfaceList[i];
			}
		}
	}
	//tmp = L"\\?\\HID#VID_303A&PID_0002#6&24b36023&0&0000#{4d1e55b2-f16f-11cf-88cb-001111000030}";
	std::vector<DEVPROPKEY> keys(2);
	ULONG keyCnts{ 0 };
	ULONG flags4{ 0 };
	cr = CM_Get_Device_Interface_Property_KeysW(tmp.c_str(), keys.data(), &keyCnts, flags4);
	if (cr == CR_SUCCESS)
	{
		std::cout << "CM_Get_Device_Interface_Property_KeysW ok" << std::endl;
	}
	else if (cr == CR_BUFFER_SMALL)
	{
		keys.resize(keyCnts);
		cr = CM_Get_Device_Interface_Property_KeysW(tmp.c_str(), keys.data(), &keyCnts, flags4);
		if (cr == CR_SUCCESS)
		{
			for (int j = 0; j < keyCnts; j++)
			{
				DEVPROPTYPE PropertyType;
				std::vector<unsigned char> PropertyBuffer;
				ULONG bufLeng{ 0 };
				ULONG flags3{ 0 };
				cr = CM_Get_Device_Interface_PropertyW(tmp.c_str(), &keys[j], &PropertyType, PropertyBuffer.data(), &bufLeng, flags3);
				if (cr == CR_SUCCESS)
				{
					std::cout << "CM_Get_Class_PropertyW  ok" << std::endl;
				}
				else if (cr == CR_BUFFER_SMALL)
				{
					PropertyBuffer.resize(bufLeng);
					cr = CM_Get_Device_Interface_PropertyW(tmp.c_str(), &keys[j], &PropertyType, PropertyBuffer.data(), &bufLeng, flags3);
					if (cr == CR_SUCCESS)
					{
						for (int k = 0; k < PropertyBuffer.size(); k += 2)
						{
							std::wstring tmp;
							tmp.resize(2);
							memcpy_s(tmp.data(), 2, &PropertyBuffer[k], 2);
							std::wcout << tmp;
						}
						for (int k = 0; k < PropertyBuffer.size(); k++)
						{
							std::cout << PropertyBuffer[k];
						}
						std::cout << std::endl;

					}
					else
					{

					}
				}
				else
				{

				}
			}
		}
		else
		{
			std::cout << "CM_Get_Class_Property_Keys error" << std::endl;
		}
	}
	else
	{
		std::cout << "CM_Get_Class_Property_Keys error" << std::endl;
	}
}
```
# HID
基本概念
报告，即设备和软件客户端的实际数据，输入报告即从HID设备发送到应用程序的数据

报告描述符，描述HID设备所支持的数据的格式与含义。定义的每个顶级集合可能包含每个类型的若干报告。
顶级集合，页为0x0001，
用法0x0001-0x0002为鼠标类
用法0x0004-0x0005为游戏控制器。
# HID体系结构
## 传输驱动
最底层，从硬件总线获得设备数据，向上一次提供标准化的HID报告
## 客户端
最上层，与应用程序通信或与系统通信，通过HID集合标识设备，关注HID报告解析
## 类驱动
中间层，协调交流最底层和最上层。为每个HID设备创建PDO物理设备对象

# HID集合
对HID控件及各自的HID使用情况的分组
例如键盘上的shift键与字母键应属于不同的分组
报告描述符定义了一个或多个顶层集合，与每个集合相关联的报告项定义了一个或多个 HID 报告。
## 顶级集合
顶级集合是一组面向特定软件使用者（或使用者类型）的功能分组。 例如，顶级集合可描述为键盘、鼠标、使用者控件、传感器、显示器等。
例如上文的
顶级集合，页为0x0001，
用法0x0001-0x0002为鼠标类
用法0x0004-0x0005为游戏控制器。
## 链接集合
作为[顶级集合](https://learn.microsoft.com/zh-cn/windows-hardware/drivers/hid/top-level-collections)中的嵌套子集合。 顶级集合可以有零个或多个链接集合。
用`HidP_GetLinkCollectionNodes`获得的东西
例如可以把几个按键组合起来形成全部按键的一个子集。
## 集合功能
即用`HidP_GetCaps`获得的结果，
- 集合的 [使用情况页](https://learn.microsoft.com/zh-cn/windows-hardware/drivers/hid/hid-usages#usage-page)本例获得0x01 和 [使用情况 ID](https://learn.microsoft.com/zh-cn/windows-hardware/drivers/hid/hid-usages#usage-id)本例获得0x05
- 集合的输入、输出和功能报告的大小（以字节为单位），指定所有输入报表的最大大小（以字节为单位）。 包括报表 ID，该 ID 位于报表数据前面。 如果未使用报表 ID，则 ID 值为零。，本例获得12
- 集合[链接集合数组中的HIDP_LINK_COLLECTION_NODE](https://learn.microsoft.com/zh-cn/windows-hardware/drivers/hid/link-collections#link-collection-array)**[结构数](https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/hidpi/ns-hidpi-_hidp_link_collection_node)**
- 对于每个报表类型，`HidP_GetButtonCaps`返回多少个`HIDP_BUTTON_CAPS`
- 对于每个报表类型，`HidP_GetValueCaps`返回多少个`HIDP_VALUE_CAPS`
- 对于每个报表类型，集合支持的按钮和值数，由 **Number**_Xxx_**DataIndices** 成员指定。
## 数据索引
索引唯一标识顶级集合的 [按钮功能数组`HIDP_BUTTON_CAPS`](https://learn.microsoft.com/zh-cn/windows-hardware/drivers/hid/button-capability-arrays) 和 [值功能数组`HIDP_VALUE_CAPS`](https://learn.microsoft.com/zh-cn/windows-hardware/drivers/hid/value-capability-arrays)中所述的每个用法。
对于`IsRange`为false的，`NotRange.Usage`表示使用情况，`NotRange.DataIndex`表示使用情况的相应数据索引
对于`IsRange`为true的，`Range.UsageMin`和`Range.UsageMax`表示使用情况，`Range.DataIndexMin`和`Range.DataIndexMax`表示使用范围的相应数据索引
## 通过数据索引提取和设置HID控制数据
先`ReadFile`同步或异步获取数据到inputBuffer。
- `HidP_GetData`可以一次性从inputBuffer中转换数据。输出形参HIDP_DATA数组包含摇杆和按钮的信息，共7个摇杆的HIDP_DATA和若干个按钮的HIDP_DATA，哪个按钮被按下，就有HIDP_DATA
  被按下的按键会有DataIndex属性，指明了这是第几个按钮。
  手柄线程中，调用GetData并遍历输出形参，哪个DataIndex出现了，同时其`On==1`或`RawValue==1`，就说明哪个按钮被按下了
  哪个DataIndex的On和RawValue共同大于死区，说明哪个摇杆被拨动了，但这个不是ScaledValue，有点难换算。
  这个DataIndex应该是在所有按键和摇杆中的。
  摇杆的范围是LogicMax和LogicMin，这两个数值应该是int型的,`[-127~127]`,可以用来把RawValue转换为ScaleValue,算法未知。
- 所以也可用`HidP_GetUsages`获取按钮信息，输出形参中写了有几个按钮按下，所有被按下按钮的index，好像是只在按键容器中的index。
  用`HidP_GetScaledUsageValue`遍历所有摇杆，直接获取摇杆的int读数，范围就是`HidP_GetValueCaps`的`LogicalMax`和`LogicalMin`。
写入数据类似
先从Cap中读出outputReport是否存在，是存在于`HidP_GetValueCaps`还是`HidP_GetButtonCaps`
例如`ValueCaps`有一个数值表示震动马达
则先用`HidP_SetUsageValue`设置数值
再用WriteFile同步或异步写入设备

# 飞鼠或鼠标
用HID访问飞鼠遇到了问题，飞鼠获取信息的时候不能加read或write权限，只有查询。再加read权限的时候createFile或ReadFile一直返回错误5。
AI说系统输入驱动会优先处理标准鼠标数据，应用程序需通过`RegisterRawInputDevices`注册原始输入接口才能绕过拦截。

因此尝试了RawInput系列
- 注册原始输入设备`RegisterRawInputDevices`的时候`RAWINPUTDEVICE`设置了`usUsagePage=0x01`和`usUsage=0x02`，即鼠标

  在windows消息中可以获得`WM_INPUT`类型的消息

- Qt类继承于`QAbstractNativeEventFilter`，重载虚函数`nativeEventFilter`订阅`WM_INPUT`类型的消息的处理函数

- 枚举设备`GetRawInputDeviceInfo`获得的`RIDI_DEVICEINFO`里面提取出的VID和PID很奇怪
HID VID  " 0x100"  PID  " 0x5"  version  " 0x0"  usagePage  " 0x0"  usage  " 0x0"
    `GetRawInputDeviceInfo`获得的RIDI_DEVICENAME里面提取出的name倒是与CM一致

- 然后在自定义消息处理函数中调用`GetRawInputData`，就可以获得`header.dwType=RIM_TYPEMOUSE`的数据，打印出来`data.mouse.lLastX`和`Y`就是鼠标的移动信息，肯定不是位置，好像是移动速度。获取的数据范围像是USB手柄的scaleValue的范围，从-127到127