使用CM系列函数
1.枚举系统当前的GUID
每次获得的GUID可以与已知的字符串比较。这样就能获得HID这一类设备的GUID
2.再从HID这一类设备中找出已知GUID的硬件设备，打印其属性
```
#include <windows.h>
#include <cfgmgr32.h>
	unsigned long data1{ 0x4d1e55b2 };
	unsigned long data2{ 0xf16f };
	unsigned long data3{ 0x11cf };
	std::array<unsigned char, 8> data4;
	data4[0] = static_cast<char>(0x88);
	data4[1] = static_cast<char>(0xcb);
	data4[2] = static_cast<char>(0x00);
	data4[3] = static_cast<char>(0x11);
	data4[4] = static_cast<char>(0x11);
	data4[5] = static_cast<char>(0x00);
	data4[6] = static_cast<char>(0x00);
	data4[7] = static_cast<char>(0x30);
	//枚举当前系统所有的GUID
	ULONG flags{ CM_ENUMERATE_CLASSES_INTERFACE };
	GUID hidClassGUID;//设备接口GUID
	ULONG indexClassID{ 0 };
	for (ULONG i = 0; ; i++)
	{
		GUID ClassGuid;//通过提供每个类的 GUID 来枚举本地计算机的已安装设备类
		CONFIGRET cr = CM_Enumerate_Classes(i, &ClassGuid, flags);
		if (cr != CR_SUCCESS)
			break;
		else
		{
			std::cout << " Data1-3Hex " << std::hex << ClassGuid.Data1 << " - " << ClassGuid.Data2 << " - " << ClassGuid.Data3;
			std::cout << " Data4 " << std::hex
				<< static_cast<ULONG>(ClassGuid.Data4[0])
				<< static_cast<ULONG>(ClassGuid.Data4[1])
				<< static_cast<ULONG>(ClassGuid.Data4[2])
				<< static_cast<ULONG>(ClassGuid.Data4[3])
				<< static_cast<ULONG>(ClassGuid.Data4[4])
				<< static_cast<ULONG>(ClassGuid.Data4[5])
				<< static_cast<ULONG>(ClassGuid.Data4[6])
				<< static_cast<ULONG>(ClassGuid.Data4[7]) << std::endl;
			if ((data1 == ClassGuid.Data1)
				&& (data2 == ClassGuid.Data2)
				&& (data3 == ClassGuid.Data3))
			{
				bool ok{ true };
				for (size_t j = 0; j < data4.size(); j++)
				{
					if (ClassGuid.Data4[j] != data4[j])
					{
						ok = false;
						break;
					}
				}
				if (ok)
				{
					indexClassID = i;
					hidClassGUID.Data1 = ClassGuid.Data1;
					hidClassGUID.Data2 = ClassGuid.Data2;
					hidClassGUID.Data3 = ClassGuid.Data3;
					for (int k = 0; k < 8; k++)
						hidClassGUID.Data4[k] = ClassGuid.Data4[k];
				}
				else
					continue;
			}

		}
	}
	//找到了HID的设备接口类的GUID
	ULONG buffLen{ 0 };
	ULONG flags2{ CM_GET_DEVICE_INTERFACE_LIST_PRESENT };
	//DEVINSTID_A dinstid;
	std::wstring tmp;
	CONFIGRET cr = CM_Get_Device_Interface_List_SizeW(&buffLen, &hidClassGUID, nullptr, flags2);
	if (cr != CR_SUCCESS)
	{
		std::cout << "CM_Get_Device_Interface_List_SizeA error" << std::endl;
	}
	else
	{
		std::vector<wchar_t> DeviceInterfaceList(buffLen);
		cr = CM_Get_Device_Interface_ListW(&hidClassGUID,
			nullptr, DeviceInterfaceList.data(), buffLen, flags2);
		if (cr != CR_SUCCESS)
		{
			std::cout << "CM_Get_Device_Interface_ListA error" << std::endl;
		}
		else
		{
			tmp.resize(DeviceInterfaceList.size());
			for (size_t j = 0; j < DeviceInterfaceList.size(); j++)
				tmp[j] = DeviceInterfaceList[j];
			if (tmp.find(L"HID#VID_303A&PID_0002") != std::string::npos)//std::find(DeviceInterfaceList.begin(), DeviceInterfaceList.end(), "VID_303A&PID_0002") != DeviceInterfaceList.end()
			{
				for (size_t i = 0; i < DeviceInterfaceList.size(); i++)
					std::wcout << DeviceInterfaceList[i];
			}
		}
	}
	//tmp = L"\\?\\HID#VID_303A&PID_0002#6&24b36023&0&0000#{4d1e55b2-f16f-11cf-88cb-001111000030}";
	std::vector<DEVPROPKEY> keys(2);
	ULONG keyCnts{ 0 };
	ULONG flags4{ 0 };
	cr = CM_Get_Device_Interface_Property_KeysW(tmp.c_str(), keys.data(), &keyCnts, flags4);
	if (cr == CR_SUCCESS)
	{
		std::cout << "CM_Get_Device_Interface_Property_KeysW ok" << std::endl;
	}
	else if (cr == CR_BUFFER_SMALL)
	{
		keys.resize(keyCnts);
		cr = CM_Get_Device_Interface_Property_KeysW(tmp.c_str(), keys.data(), &keyCnts, flags4);
		if (cr == CR_SUCCESS)
		{
			for (int j = 0; j < keyCnts; j++)
			{
				DEVPROPTYPE PropertyType;
				std::vector<unsigned char> PropertyBuffer;
				ULONG bufLeng{ 0 };
				ULONG flags3{ 0 };
				cr = CM_Get_Device_Interface_PropertyW(tmp.c_str(), &keys[j], &PropertyType, PropertyBuffer.data(), &bufLeng, flags3);
				if (cr == CR_SUCCESS)
				{
					std::cout << "CM_Get_Class_PropertyW  ok" << std::endl;
				}
				else if (cr == CR_BUFFER_SMALL)
				{
					PropertyBuffer.resize(bufLeng);
					cr = CM_Get_Device_Interface_PropertyW(tmp.c_str(), &keys[j], &PropertyType, PropertyBuffer.data(), &bufLeng, flags3);
					if (cr == CR_SUCCESS)
					{
						for (int k = 0; k < PropertyBuffer.size(); k += 2)
						{
							std::wstring tmp;
							tmp.resize(2);
							memcpy_s(tmp.data(), 2, &PropertyBuffer[k], 2);
							std::wcout << tmp;
						}
						for (int k = 0; k < PropertyBuffer.size(); k++)
						{
							std::cout << PropertyBuffer[k];
						}
						std::cout << std::endl;

					}
					else
					{

					}
				}
				else
				{

				}
			}
		}
		else
		{
			std::cout << "CM_Get_Class_Property_Keys error" << std::endl;
		}
	}
	else
	{
		std::cout << "CM_Get_Class_Property_Keys error" << std::endl;
	}
}
```
