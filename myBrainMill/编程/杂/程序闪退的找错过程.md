# 问题
开发电脑上能正常运行，第一台测试电脑没问题。
第二台测试电脑闪退，未留下日志，只留下了windows事件记录
从windows事件记录看出vcruntime.dll报了内存错误，于是安装了合适的vc_redis
再次运行还是闪退，从windows事件记录看出ucrtbase.dll报了错误，比较两台电脑，发现闪退这台电脑的版本很低。于是替换了合适版本的ucrtbase.dll。
# 复盘
发布程序前应该看看dll少不少，版本是否合适。
这次没有日志出来，说明spdlog运行之前就错了，既然没有日志，能不能有dump文件出来。
以后release版本也要生成pdb，配合dump文件和汇编能大概找出出错位置。dump文件现在是第三方程序procdump生成的，将来能不能从代码生成，可以的。
# 工具
## Dependencies
可以看到程序依赖的dll，发布的时候可以大概看看是否少dll文件，以及文件版本
## process monitor
可以用程序名字作为filter，记录程序从启动到退出，执行的记录，例如调用dll，访问文件，访问注册表，访问网络。
上述闪退看了process monitor输出的事件，看不出来问题
## procDump
### 概述
只能用procDump来输出dump文件
`procdump.exe -ma -w -e 进程名字`
输出的dump文件会自动按时间保存在当前文件夹
使用vs打开dump文件，配合源代码和pdb文件可以知道哪行代码出了问题。
### 步骤1
运行procdump
管理员权限的命令行
`procdump.exe -ma -e -w 进程名`
进程名不需要带.exe
### 步骤2
运行程序
如果提示multiple name，把文件夹改个名字，或者exe文件改个名字。实在不行重启
等待程序崩溃退出，procdump就生成了dmp文件，在工作文件夹。
### 步骤3
生成的dump文件可以用vs打开
- 如果有debug版本的exe产生的dump文件，配合pdb文件和源码能准确看到哪里有问题
- 如果有release版本的exe产生的dump文件，只能看汇编
- 如果有release版本并且设置了pdb为debug的exe产生的dump文件，配合pdb文件和汇编能大概看到哪里有问题

例如
testRemoteNode.exe_260107_170725.dmp是debug版本的dump文件，配合pdb和cpp能够准确找到出错位置
testRemoteNode.exe_260107_170823.dmp是debug版本的dump文件，配合pdb和cpp能够准确找到出错位置

22a.exe_260107_172012.dmp是release无pdb的dump文件，只能看汇编
testRemoteNode.exe_260107_172647.dmp是release已经pdb设置为debug版本的dump文件，配合pdb和汇编能大概找到出错位置
dtestRemoteNode.exe_260107_181210.dmp是release已经pdb设置为debugfull版本的dump文件，配合pdb和汇编能大概找到出错位置
testRemoteNode.exe_260107_181613.dmp是release已经pdb设置为debugfast版本的dump文件，配合pdb和汇编能大概找到出错位置
# 代码里生成dmp
## windows
核心函数`MiniDumpWriteDump`，把当时出错的信息保存在一个文件里
[MiniDumpWriteDump 函数 (minidumpapiset.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/win32/api/minidumpapiset/nf-minidumpapiset-minidumpwritedump)
核心过程
```
#include <windows.h>
#include <DbgHelp.h>
#include <tlhelp32.h>
//定义一个异常处理函数
LONG WINAPI MyUnhandledExceptionFilter(EXCEPTION_POINTERS* ExceptionInfo)
{
	//创建一个dmp文件
	HANDLE hFile = CreateFile(L"crash.dmp", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile != INVALID_HANDLE_VALUE) {
		MINIDUMP_EXCEPTION_INFORMATION dumpInfo = { 0 };
		dumpInfo.ThreadId = GetCurrentThreadId();
		dumpInfo.ExceptionPointers = ExceptionInfo;
		dumpInfo.ClientPointers = FALSE;
		//核心函数，MiniDumpNormal包含信息少，使得dmp尺寸小，已经可以包括callstack
		MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &dumpInfo, NULL, NULL);
		CloseHandle(hFile);
	}
	return EXCEPTION_EXECUTE_HANDLER;
}
int main(int argc, char *argv[])
{
	//使用异常处理函数
	SetUnhandledExceptionFilter(MyUnhandledExceptionFilter);
	//可以故意制造一个异常
	return 0;
}
```
按照ms的建议使用单独的一个线程存储dmp。
不用设置程序的管理员权限，c++异常是EHsc。
使用MiniDumpNormal选项，保存的dmp文件很小。
结合release版本的exe和普通pdb，就能看到callstack。
因为事先知道msvcp140.dll版本不对导致闪退，所以也提供了转存dmp时候使用的错误版本的dll。这就能够看到出错时候的汇编，在pdb帮助下能看到汇编中也有函数名，便于定位错误。
# 没看懂的一些SxS
+---------------------+ 
| MSVCP140.DLL        |  ← C++ STL 实现（每版独立）
+---------------------+
| VCRUNTIME140.DLL    |  ← 异常、RTTI、启动例程（每版独立）
+---------------------+
|    UCRTBASE.DLL     |  ← malloc, printf, time 等（系统级共享）
+---------------------+
| Windows System      |  ← UCRT 合并入系统，通过Windows Update维护
————————————————
VC++ 2015、2017、2019、2022均可复用同一份 `ucrtbase.dll` ，只需各自携带专属的 `msvcp140.dll` 和 `vcruntime140.dll` 即可。
##### 清单文件（Manifest）的关键作用

为了确保正确绑定特定版本的非UCRT组件，MSVC使用XML格式的清单文件精确声明依赖关系。例如

[关于专用程序集 - Win32 apps | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/win32/sbscs/about-private-assemblies-)

没太看懂微软说的

https://blog.csdn.net/chenlycly/article/details/142907923

[windows 下C++生成Dump调试文件与分析_C 语言_脚本之家](https://www.jb51.net/article/280570.htm)