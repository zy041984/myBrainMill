## BOM
把Unicode码点值为FEFF的字符，表示一个二进制文件的字节顺序。
从Unicode3.2开始，U+FEFF只能出现在字节流的开头，只能用于标识字节序。
intel处理器为LE，在UTF8编码格式读出的BOM为EF BB BF
在UTF16编码格式读出的BOM为0xFF 0xFE
在UTF32编码格式读出的BOM为0x00FF 0x00FE 0x0000 0x0000

## LE
即内存低地址的字节写在数据类型的低位，内存高地址的字节写在数据类型的高位
内存地址 0x地址+1    AB
内存地址 0x地址+2    CD

读出的内容为 CDAB

可以定义一个两字节的short型变量十进制10000十六进制2710
intel处理器的程序内存如下
内存低地址的内容为0001 0000即十六进制10 
内存高地址的内容为0010 0111即十六进制27

# 知乎专栏
[刨根究底字符编码之一——关键术语解释(上) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/27012967)
https://zhuanlan.zhihu.com/p/27026033
## 术语
### 位bit
### 字节byte
PC上内存寻址一般以字节为单位
从左到右依次是第7位到第0位，与书写顺序相同
### 字word
CPU一次操作处理的实际bit位数量，通常由总线宽度决定

### 编码encode解码decode
把信息从一种形式转换为中间形式为编码
把信息从中间形式转换为原始形式为解码

### 字符集CharacterSet
一些文字与符号形成的一个集合，如ASCII，GB2312，BIG5
国标，微软，ISO，Unicode联盟各有字符集
国标如 GB2312、GB13000、GB13000-2000、GB13000-2005
微软如GBK即CP936
ISO如ISO 10646-1
Unicode联盟如Unicode1.1、Unicode3.0、Unicode4.1、Unicode6.2

### 字符编码CharacterEncoding
即某个字符集中的文字或符号怎么写成二进制或十进制，以保存或传输

### 字符编码模型CharacterEncodingModel
怎么把一个字符集用不同的编码形式制作出来，即一个字符集可以用多种编码形式。
例如Unicode的概念中，字符编码模型分为5个层次
1. **抽象字符表 ACR**(abstract character set)，即有哪些字母符号，可能是无上限可扩展
2. **编号字符表CCS**(coded character set)，即每个符号有一个数字编号
   - 这个编号可以是一个二维坐标，可以是一个标量
   - 这些编号形成了一个范围，标量的范围，或者二维坐标的范围，这就是编号空间code space。例如Unicode标准每个平面有$2^{16}$个坐标，形成了一个平面的编号空间。
   - 编号空间的一个位置就是**码点code point**，某字符码点的坐标值就是**码点值**或**码点编号**。 
   - Unicode标准中，一个抽象字符可能对应多个码点，比如码点编号为U+51C9与U+F979的这两个码点实际上是同一个字符“凉”，这是为了兼容韩国字符集标准。也存在一个抽象字符由多个码点组合形成，如如à，由码点编号为U+0061的基本字符字母“a”和码点编号为U+0300的组合字符读音符号“̀”所共同组成
3. **字符编码方式CEF**(coded encoding form)，即把数字编号(码点值)编码为某种逻辑上的数值，这个数值就是**码元Code Unit**的序列
   - 计算机表示的整数范围有限，抽象字符集中的元素数量可能无限。所以字符可能由一个**码元Code Unit**或多个码元构成，长度可变，是个序列。每个码元可分为多字节或单字节。
      - 多个单字节整数凑在一起间接表示，UTF8，UTF16。
          - UTF8为多字节编码单字节码元。例如"汉"三个码元 0xE6 0xB1 0x89，每个码元单字节
          - UTF16为多字节编码多字节码元。例如"汉"一个码元 0x6C49，每个码元双字节
          - GB系列为多字节编码单字节码元
      - 一个足够长的多字节整数直接表示，UTF32。多字节编码多字节码元。
          - UTF32为多字节编码多字节码元。例如"汉"一个码元 0x00006C49，每个码元四字节
   - 怎么兼容ASCII
   - 设计好这个方法，输出的就是码元。UTF8，UTF16，UTF32就是指的Unicode字符集的字符编码方式CEF
4. **字符编码模式CES**(coded encoding scheme)，即把逻辑上的码元映射到物理上的字节序列，即字节流
   - 开始与硬件相关。
      - UTF16和UTF32这种多字节码元，必须使用一个字符0xFEFF，又称**零宽度不中断空格**Zero Width No-break space，来指定字节序byte-order是BE或LE  
      - UTF8采用单字节码元，不存在字节序问题
   - 这字节序列就是平常经常打交道的最终编码 
5. **传输编码语法TES**(transfer encoding syntax)，即把字节序列进一步适应性处理，例如适应压缩或者适应email协议
因此一个抽象字符，对应的UTF码点值(字符编号)通常是相同的，但因为编码方式不同(UTF8, UTF16)有不同的的码元序列，再应用到不同硬件体系的编码模式，最终会得到不同的字节流。

## 一些字符编码方案例子
### ASCII 英语国家的字符编码方案
- 128个抽象字符
- 按某个顺序排列，大写字母顺序排列，小写字母顺序排列
    0-31为不可显示不可打印字符
    32 可显示不可打印的空格键
    33-126 可显示可打印的字母，数字，符号
    127 不可显示不可打印的字符DEL
- 用8个bit来表示这128个抽象字符，最高bit为0
- 字符编号就是字符编码，就是字节流

### ISO8859 兼容ASCII的非英语国家字符编码方案
使用了ASCII码中未使用的第8bit来包括更多的符号
一共有15个字符集，即ISO8859-1、ISO8859-2、……
每个字符集都是0-127个字符同ASCII，128-159未定义，160-255实际使用
使用最普遍的是西欧字符集，即ISO8859-1又名Latin-1
https://zhuanlan.zhihu.com/p/27075810

### 简体汉字编码方案(GB2312,GBK)及全角、半角、CJK
这些字符集都是**双字节字符集DBCS**(DoubleByteCharacterSet)，两字节的中文与一字节的ASCII完全兼容，可以并存于同一个文件内。
#### GB2312特点
兼容ASCII，多字节编码，单字节码元。
如果一个字节是0~127，则需解读为一个ASCII字节；否则该字节与下一个字节(也需大于127)共同组成GB编码定义的其他字符，如汉字。
GB2312，GBK，GB18030的编码方案实现了向下兼容
#### 全角半角
GB2312编码方案把ASCII里本来就有的数字标点字母的单字节编码的字符，又编了一个双字节的字符，就是全角字符，显示上与汉字字符的像素等宽。而ASCII里的字符为单字节编码，显示上为汉字字符的像素宽度一半，称为半角字符。

#### GBK特点
兼容GB2312，但扩充了繁体和生僻字，日文。
编码与GB2312不同，只要高字节大于127即表示这是一个汉字的开始，下一个字节无需也大于127.
基本上等同于微软的代码页936

#### GB18030
为了取代GBK，增加了字符，成为了中日韩统一表意文字字符。

#### 区位码
GB2312字符集被分为94区94位，每个字符所在的区号和位号就是区位码，范围1-94十进制

#### 国标码(交换码)
为避免与ASCII的0-32个字符重复，把每个汉字的区码和位码均增加32，范围33-126十进制

#### 内码，即GB2312的机内码
为避免与ASCII冲突，每个字节的最高位从0换成1，即每个字节增加128，范围151-254

#### 外码，输入码
设想就是给所有拼音建立一个变长的容器，每个容器的元素就是一个拼音如“fa”，然后再把所有这个读音的汉字放到容器的这个元素里。当输入拼音fa时，列出容器内所有元素，用户再从UI中选出具体某一个汉字。

#### 字形码(输出码，字模码，字型码)
为了显示或打印，从内码找到字体文件中该汉字的点阵代码或字形代码。

### ANSI和代码页
#### 代码页(内码表)
即字符集的某种字符编码方式在计算机的具体编码实现。
微软在windows中把每种字符编码方案定义了一个代码，称为**代码页codepage**。即实现了每个特定字符集某种字符编码方式的字符编码对照表。即码元序列-字节序列(与操作系统相关)或CEF-CES的对照表。
- 中文的GB编码为代码页936
- ISO8859的代码页为1252
#### ANSI
ISO8859，GB2312等这些兼容ASCII又互不兼容的方案在Windows中统称为ANSI。每个操作系统当前环境下会用ANSI来代替当前的代码页。比如我的电脑Locale区域设置为中文，当前环境的代码页即为GB2312，我电脑的记事本的"另存为ANSI"即意味着"另存为GB2312"。
这样，所有使用非Unicode的程序可以正常按照某种代码页来显示字符。

## Unicode编码方案
为了大一统，解决你获得了一个中文文本文件，却不知道该设置为哪个ANSI才能正确显示的问题。
### 字符集
涵盖了人类使用的所有字符，并为每个字符分配唯一的码点值。
现在字符被分为17个平面plane，每个平面上有$2^{16}$个码点，每个码点有一个正式**码点名称**:U+码点编号，如U+0041，U+4E25
有大量未使用空间，将来可以通过增加平面的方式扩展

### 字符编码方式
多字节编码，UTF8为单字节码元，UTF16为双字节码元，UTF32为四字节编码

 | CEF | 码元类别 | 编码字节数 | 字节序 | 可扩展性 |
 | ---- | ---- | ---- | ---- | ---- |
 | UTF8 | 单字节 | 单字节(ASCII)或多字节 | 无字节序问题 | 理论上支持的字节数无上限 |    
 | UTF16 | 双字节 | 双字节(BMP)或四字节(增补平面) | 码元有字节序问题 | 最多支持四个字节 |
 | UTF32 | 四字节 | 四字节 | 码元有字节序问题 | 最多支持四个字节 |

### UTF8的优缺
+ U+0000到U+007F的码点值，直接转换到UTF8单一字节码元，0x00到0x7F，与ASCII相同
+ 带有前缀码，码元序列的第一个字节指明了后面所跟的字节数目。容错性好，码元序列的中间某个字节有误，不会影响后续码元序列。
+ 从字节流任意位置开始可以有效找到一个字符的起始
+ 与字节顺序无关，不需要BOM
+ 码元序列的每个字节只能以0或10或110或1110或11110开头
+ 可以通过屏蔽位和移位快速读写
+ 字符串比较的返回结果相同
- 码元序列变长，无法从字节数判断字符数。
- 8bit的单字节码元会被email网关过滤，因为Internet信息传输最开始是7bit的ASCII字符。
### UTF8的编码细节
每个字节的高几位bit为前缀码，1开始，0结束，第一个字节的前缀码中有几个1表示本字符有几个字节
第一个字节最高bit为0，则为单字节编码的ASCII
第一个字节最高bit为11，则为多字节编码的首字节，一共有几个1，就表示该字符的字节数
双字节的第二个，或者三四字节的后续字节，高位为均10
其余的bit数填写具体的码元序列
即，单字节 0xxxxxxx                                           码点值范围 0x0000-0x007F
双字节 110xxxxx 10xxxxxx                                   码点值范围 0x0080-0x07FF
三字节 1110xxxx 10xxxxxx 10xxxxxx                    码点值范围0x0800-0xFFFF
四字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx     码点值范围0x100000-0x1FFFFF
[刨根究底字符编码之十三——UTF-16编码方式 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/27417641)
### UTF16的优缺
- 变字节编码，16位码元
- 自同步，带有前缀码
- 非传递性，某个字节有误，不会影响后续码元序列
- 扩展性差
- 需要指定字节顺序
- U+0000到U+007F的码点值，也需要16bit，与ASCII不同
### UTF16的编码细节
Unicode的字符集的符号数量超过16bit能表示的范围，因此UTF16使用代理机制。
基本平面即U+0000到U+FFFF，除开U+D800到U+DFFF这个范围内，字符的字符编号与字符编码相同。
其余增补平面的字符的码点位置U+100000到U+10FFFF与字符编码不是直接映射，需要通过代理机制计算。

增补平面的码点位置的字符，其编码由两部分组成，引导代理，尾随代理。
引导代理码元格式，1101 10pp ppxx xxxx，取值范围0xD800-0xDBFF
尾随代理码元格式，1101 11xx xxxx xxxx，取值范围0xDC00-0xDFFF
pppp表示增补平面序号，取值范围1-16，剩余16bit表示某个增补平面上的码点

这样UTF16为16位码元，变字节长度编码
- BMP平面码元序列为2字节，码元序列不在D800到DFFF范围内
- 增补平面码元序列为4字节，引导代理码元范围D800到DBFF，尾随代理码元范围0xDC00到0xDFFF
根据一个字节的范围就能判断该字节属于某个码元序列的哪个部分，所以UTF16具有以下特性
- 自同步性：通过仅检查一个码元就可以判断当前字符的下一个字符的起始码元，每个字符码元的边界很明确。
- 非传递性：单独的一个UTF-16码元出错涉及的只是一个字符，不会传递到文本的其他部分去，因此，即使文本中某些字符数据遭到破坏，其影响也只是局部性的。

winAPI现已改为UTF16LE的宽字符版本
Windows平台下的UTF16编码默认为UTF16LEwithBOM，如果使用ANSI编码，则为GBK编码无BOM

### UTF32优缺
直接把码点位置写为4字节的码元，无需计算
- 固定字节长度，码元长度4字节
- 码元需要指定字节顺序

## windows记事本的一个例子
联的GBK内码为1100 0001 1010 1010
通的GBK内码为1100 1101 1010 1000
也可以被理解为正确的UTF8双字节码元序列，所以用UTF8解读时，会得到其他的合法字符


## VS相关

是否“Advanced"的"character set"选项只是用来确定CRT的版本是使用unicode字符集还是codepage字符集，还是ansii字符集的。
如果开发新程序，直接考虑用Unicode字符集就行
如果考虑跨平台，就不要使用ms的自定义宏_T，自定义的_t前缀函数等。避免使用CString，直接使用wchar_t，字符串加L，windows下变成UTF16BE的
### MFC
MFC支持Unicode或Multibyte Character Set两种，其中Unicode形式是用wchar_t存储UTF16字符；MBCS是以char存储locale字符，应该是GBK或GB2312的字符。
CString根源于TCHAR数据类型，如果定义了_UNICODE，则TCHAR被视为wchar_t存储UTF16；如果定义了_MBCS，则TCHAR被视为char存储GBK;
使用Unicode时，或MBCS时
- 字符串用_T宏包围定义
- char类型替换为TCHAR类型
- char\*类型替换为LPTSTR类型
- const char\*类型替换为LPCTSTR类型
- 一些函数如strcmp会根据_UNICODE或_MBCS被映射为wcscmp或_mbscmp
[Unicode and Multibyte Character Set (MBCS) Support | Microsoft Learn](https://learn.microsoft.com/en-us/cpp/atl-mfc-shared/unicode-and-multibyte-character-set-mbcs-support?view=msvc-170)

### CRT
很多c运行时库函数的SBCS版本同时也可以处理MBCS
使用UTF16，即2字节的wchar_t，字符或字符串前面加L
同MFC部分
使用_UNICODE或_MBCS来确定字符串的类型以及某些函数被映射为A或W版本
使用TCHAR.h的_T宏，TCHAR类型
Windows 10 version 1803 (10.0.17134.0)版本之后，setlocale支持”.UTF8“的locale了
https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/setlocale-wsetlocale?view=msvc-170

### 编译器选项
#### `/source-charset`或`/utf-8`
指定源文件的字符集，源文件通过这个字符集转换为内码，输入到预处理阶段，如`/source-charset:utf-8`
默认情况，如果源文件有BOM，就可以判断是哪种UTF的CEF了。如果没有BOM，就要自行推断codepage，可以用这个选项来指定。
#### `/execution-charset`或`/utf-8`
指定预处理阶段过后，源代码的某些字符串或字面值按照哪种字符集输入到编译阶段，如`/execution-charset:utf-8`
默认情况，如果源文件有BOM，就可以判断是哪种UTF的CEF了。如果没有BOM，就要自行推断codepage，可以用这个选项来指定。