
# 加密方法
加密方法中，算法是公开的，大家都知道怎么计算。但秘钥是保密的，没有秘钥就没办法还原明文。
如果加密解密双方使用相同的秘钥，就称为对称加密
如果加密解密双方使用不同的秘钥，就称为非对称加密

# 对称加密的通信流程
发送端->明文->使用秘钥A加密->得到密文->公网发送  
接收端<-明文<-使用秘钥A解密<-得到密文

问题，如何把秘钥A安全地发送给接收端，既然能安全地发送秘钥给对方，那直接发送明文就行了，何必费事

# 非对称加密的通信流程
发送端->明文->使用接收端的公开秘钥C加密->得到密文->公网发送  
接收端<-明文<-使用自己的私有秘钥D解密<-得到密文

接收端的公开秘钥可以公开，谁都能获得，拥有者都可以用C加密明文再发给接收端。
只拥有公开秘钥和密文是不能还原出明文的，只能用私有秘钥D和密文得出明文

问题，怎么证明接收端在网络的公开秘钥真正是他的，被别人偷偷篡改了怎么办
解决办法，数字证书认证机构CA来公证这个公钥就是某某的。某某的公钥必须与CA给某某的证书在一起才有效。


有了非对称加密，SSL的通信过程如下

|  序号  |  客户端  |  方向  |  服务器端  |
|  ----  |  ----  |  ----  |  ----  |
|  1  |  客户端hello  |  ->  |    |
|  2  |     |  <-   |   服务器端响应hello  |
|  3  |     | <- |服务器端把自己的公钥A发给客户端|
|4||<-|服务器端声明这次握手结束|
|5|客户端生成一个随机字符串B，使用A加密|->||
|6|客户端声明后续通信使用B加密|->|||
|7|客户端发送全部报文的校验值D，声明握手结束|->||
|8||<-|服务器端用自己的私钥C解密报文5，得到字符串B，同样计算全部报文的校验值E，声明握手结束|
|9|后续应用层报文使用B加密解密|-><-|后续应用层消息使用B加密解密|


## 数字签名
9流程后续应用层报文不仅加密，也使用报文摘要(Message Authentic Code)MAC来保证未篡改，这就是数字签名
别人不能冒充客户端的签名，数字签名能保证消息未被篡改

报文使用HASH算法生成信息摘要，用B加密生成数字签名。数字签名与原文一起发到服务器端。
服务器端用B解密得到原文和数字签名，用HASH算法对原文生成信息摘要，与接收到的信息摘要进行比较，相同说明信息未被篡改

## 数字证书
数字证书认证机构CA来公证这个公钥就是某某的。某某的公钥必须与CA给某某的证书在一起才有效。

## 总结非对称加密的通信流程
1.客户端向服务器端要公钥，使用明文通信
2.服务器端把公钥发给客户端，使用明文通信
3.客户端生成随机数，并用服务器端的公钥加密，传给服务器端，使用非对称加密
4.服务器端用私钥获得随机数
5.服务器与客户端接下来使用这个随机数进行对称加密

# https的概念
http+加密+认证+完整性保护=https
加密用来解决明文通信
认证解决http不验证通信双方身份
完整性保护解决Http无法证明报文完整性

http的通信接口部分用SSL和TLS协议
通信接口部分不是Http直接使用TCP，而是HTTp先与SSL通信，再由SSL与TCP通信

SSL为secure socket layer
TLS为transport layer security

# SSH的概念
SSH是由客户端和服务端的软件组成的，用于computer之间创建加密连接通信，提供了一种安全的方式来远程登录到另一台计算机并操控它，比如我们通过SSH登录远端服务器。
如何进行身份验证，使用用户名密码，或一组公钥私钥
一般使用端口22


[Authentication documentation - GitHub Docs](https://docs.github.com/en/authentication)
# github的文档
#提交签名验证 #两步验证 #SSH
为了向github进行authentication，证明登录者的身份，可以用多种途径
- 浏览器
- github Desktop
- 其他桌面程序
- API或命令行
每种登录方法都有验证方法
- 用户名密码两步验证，或者passkey
- 个人权限token
- SSH key
## 浏览器的验证
个人用户需要使用用户名和密码，或者passkey。会逐渐过渡到两步验证。
### 用户名和密码并使用两步验证
输入用户名和密码后，手机将接收到一个基于时间的一次性密码Time-based one time password(TOTP)，还需要输入这个密码才能登录
### passkey
这种方法也就是无需密码的安全登录，推荐浏览器也使用这种方法登录
### HTTPS
即使在防火墙或代理后面，也可以使用HTTPS访问所有仓库
- 如果使用github CLI，要么使用个人token来进行验证，要么使用浏览器来进行验证。
- 如果不使用github CLI，必须使用个人token来进行验证。基于密码的git验证方式已经不被支持了。
    - 当GIT提醒你输入密码时，输入你的个人token
    - 或者使用git credential manager这样的帮助程序
### SSH
也可以使用SSH来访问所有仓库，但要小心本地SSH端口需要正常工作
- 使用github CLI时，要把个人的公钥上传到github
- 不使用github CLI时，自行生成一对公钥私钥，并把公钥上传到github

## 管理你的个人token
使用命令行如git的时候，可以用个人token来代替密码，现在好像密码被废弃了
有两个类别的个人token，细粒度的和经典的个人token
个人token与用户紧密相关。用户可以为自己的个人token设定权限。
细粒度token功能更全面，每个token只能访问特定的仓库，只能有特定的权限。必须有过期时间。
要妥善保管自己的个人token。token过期之后就要分配新的token。
命令行登陆的时候只能使用HTTPS，不能使用SSH。有时候git客户端可能把这个用户名和个人token进行缓存，或存在一个文本文件中。
https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens
## github的服务器的SSHkey的fingerprints
当连接到一个github的服务器时，可以查看SSHkey的指纹，它们是公开的。如果你连接的服务器的SSHkey的指纹不对，那就是一个假冒的服务器
## 2步验证
逐渐开始必须使用2步验证。成功后，可以增加一个security key，原理类似于apple touch ID。背后的技术是WebAuthn，现代的浏览器应该都支持。
或者也可以为账户增加一个passkey，这个passkey同时满足密码和两步验证，所以一步就可以登录github。
## passkey
passkey是一对公钥和私钥，被安全地保存在你控制的一个地方。只要提供了这个passkey，就认为是你。


开启两步验证的步骤
1. 登录github，在settings中的password authentication中选择2fa。
2. ipad安装微软的authenticator，打开
3. ipad扫描网页的QR码
4. 在网页上输入ipad的动态密码
5. 在随后的网页上点击保存recovery code
微软的authenticator